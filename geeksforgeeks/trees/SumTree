#### following implementation takes O(n^2) in worst case and O(nlogn) in avg case ####

bool isLeaf(Node* node){
    return !node->left && !node->right;
}

int sum(Node* root){
    if(!root)
        return 0;
    else
        return root->data+sum(root->left)+sum(root->right);
}

bool isSumTree(Node* root)
{
     // Your code here
     if(!root)
         return true;
     else if(isLeaf(root))
         return true;
     else{
         int leftSum=sum(root->left);
         int rightSum=sum(root->right);
         if(root->data!=leftSum+rightSum)
             return false;
         else{
             return (isSumTree(root->right) && isSumTree(root->left));
         }
     }
}


##### Hack method for O(n) #####
int sumOfNodes(Node* root,bool& checksum){
    if(!root)
        return 0;
    else if(!root->left && !root->right)
        return root->data;
    else{
        int leftsum=sumOfNodes(root->left,checksum);
        int rightsum=sumOfNodes(root->right,checksum);
        if(root->data!=leftsum+rightsum){
            checksum=false;
            return root->data+leftsum+rightsum;
        }
        else
            return 2*root->data;
    }
}

bool isSumTree(Node* root)
{
     // Your code here
     if(!root)
         return true;
     else if(!root->left && !root->right){
         return true;
     }
     else{
         bool checksum=true;
         sumOfNodes(root,checksum);
         if(checksum)
             return true;
         else
             return false;
     }
}
